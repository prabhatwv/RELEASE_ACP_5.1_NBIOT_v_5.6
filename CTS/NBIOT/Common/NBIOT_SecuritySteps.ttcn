/******************************************************************************/
// @copyright   Copyright Notification
//   No part may be reproduced except as authorized by written permission.
//   The copyright and the foregoing restriction extend to reproduction in all media.
//   Trademark 2019, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).
//   All rights reserved.
// @version: 36.523-3 v15.3.0
// $Date: 2018-12-04 11:43:45 +0100 (Tue, 04 Dec 2018) $
// $Rev: 23299 $
/******************************************************************************/
module NBIOT_SecuritySteps {

  import from NBIOT_RRC_ASN1_Definitions language "ASN.1:2002" all with {encode "UNALIGNED_PER_OctetAligned"};
  import from Common4G5G_Templates all;
  import from CommonAspDefs all;
  import from CommonDefs all;
  import from EPS_NAS_Templates all;
  import from EPS_NAS_TypeDefs all;
  import from EUTRA_NB_CommonDefs all;
  import from EUTRA_NB_SecurityDefinitionsAndExternalFunctions all;
  import from EUTRA_NB_SecurityFunctions all;
  import from NAS_CommonTemplates all;
  import from NAS_CommonTypeDefs all;
  import from NAS_AuthenticationCommon all;
  import from NBIOT_ASP_SrbDefs all;
  import from NBIOT_ASP_TypeDefs all;
  import from NBIOT_CellInfo all;
  import from NBIOT_CommonDefs all;
  import from NBIOT_Component all;
  import from NBIOT_ConfigurationSteps all;
  import from NBIOT_Imported_EUTRA_ASN1_Types all;
  import from NBIOT_RRC_Templates all;
  import from NBIOT_SRB_DRB_Templates all;
  import from NBIOT_SecurityFunctions all;
  import from NBIOT_Security_Templates all;
  import from NasEmu_CtrlFunctions all;
  import from NBIOT_Timing all;
  import from VZW_NBIOT_AlgMilenage all;
  import from Parameters all;

  /*
   * @desc      Common function to configure AS security
   * @param     p_CellId
   * @param     p_SYSTEM_CTRL_REQ
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_SS_AS_SecurityConfig(NBIOT_CellId_Type p_CellId,
                                        template (value) NB_SYSTEM_CTRL_REQ p_SYSTEM_CTRL_REQ) runs on NBIOT_PTC
  {
    SYS.send(p_SYSTEM_CTRL_REQ);
    if (valueof(p_SYSTEM_CTRL_REQ.Common.ControlInfo.CnfFlag) == true) {
      SYS.receive(car_NB_AsSecurity_CNF(p_CellId));
    }
  }

  /*
   * @desc      configure AS integrity protection at the SS
   * @param     p_CellId
   * @param     p_AS_IntegrityInfo
   * @param     p_TimingInfo        (default value: cs_TimingInfo_Now)
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_SS_RRC_EnableIntegrityProtection(NBIOT_CellId_Type p_CellId,
                                                    NB_AS_IntegrityInfo_Type p_AS_IntegrityInfo,
                                                    template (value) TimingInfo_Type p_TimingInfo := cs_TimingInfo_Now) runs on NBIOT_PTC
  {
    f_NBIOT_SS_AS_SecurityConfig(p_CellId, cas_NB_AsSecurityStart_REQ(p_CellId, cs_NB_AS_IntProtActivate(p_AS_IntegrityInfo), p_TimingInfo));
  }

  /*
   * @desc      enable PDCP integrity and ciphering at the SS
   * @param     p_CellId
   * @param     p_AS_IntegrityInfo
   * @param     p_AS_CipheringInfo
   * @param     p_TimingInfo        (default value: cs_TimingInfo_Now)
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_SS_RRC_EnableIntProt_CiphULandDL(NBIOT_CellId_Type p_CellId,
                                                    NB_AS_IntegrityInfo_Type p_AS_IntegrityInfo,
                                                    NB_AS_CipheringInfo_Type p_AS_CipheringInfo,
                                                    template (value) TimingInfo_Type p_TimingInfo := cs_TimingInfo_Now) runs on NBIOT_PTC
  {
    f_NBIOT_SS_AS_SecurityConfig(p_CellId, cas_NB_AsSecurityStart_REQ(p_CellId, cs_NB_AS_IntProt_CiphActivate(p_AS_IntegrityInfo, p_AS_CipheringInfo), p_TimingInfo));
  }

  /*
   * @desc      release AS security at the SS
   * @param     p_CellId
   * @param     p_TimingInfo        (default value: cs_TimingInfo_Now)
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_SS_RRC_ReleaseSecurity(NBIOT_CellId_Type p_CellId,
                                          template (value) TimingInfo_Type p_TimingInfo := cs_TimingInfo_Now) runs on NBIOT_PTC
  {
    f_NBIOT_SS_AS_SecurityConfig(p_CellId, cas_NB_AsSecurityRelease_REQ(p_CellId, p_TimingInfo));
  }

  /*
   * @desc      re-establishment of AS security for SRB1 and the given DRBs after RRC Connection Reestablishment
   * @param     p_CellId
   * @param     p_SecurityParams
   * @param     p_Procedure
   * @return    NBIOT_SecurityParams_Type
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_SS_AS_ReestablishResumeSecurity(NBIOT_CellId_Type p_CellId,
                                                   NBIOT_SecurityParams_Type p_SecurityParams,
                                                   NBIOT_CipherActTimePrcedure_Type p_Procedure)
    runs on NBIOT_PTC return NBIOT_SecurityParams_Type
  {
    var EUTRA_ASN1_PhysCellId_Type v_PhysicalCellIdentity := f_NBIOT_CellInfo_GetPhyCellId(p_CellId);
    var NB_CarrierFreq_Type v_NB_CarrierFreq := f_NBIOT_CellInfo_GetEARFCN(p_CellId);
    var NBIOT_SecurityParams_Type v_SecurityParams := f_NBIOT_InitAS_KeyRefresh(v_PhysicalCellIdentity, v_NB_CarrierFreq.DL.carrierFreq_r13, p_SecurityParams);

    v_SecurityParams.AS_Ciphering.ActTimeList := f_NBIOT_RRC_CipherActTime_Get(p_CellId, p_Procedure);

    f_NBIOT_SS_RRC_EnableIntProt_CiphULandDL(p_CellId,
                                             v_SecurityParams.AS_Integrity,
                                             v_SecurityParams.AS_Ciphering);
    return v_SecurityParams;
  }

  /*
   * @desc      to restart the AS security e.g. when a DRB is added after RRC connection has been established already
   * @param     p_CellId
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_SS_RRC_RestartSecurity(NBIOT_CellId_Type p_CellId) runs on NBIOT_PTC
  {
    var NBIOT_SecurityParams_Type v_SecurityParams := f_NBIOT_Security_Get();

    v_SecurityParams.AS_Ciphering.ActTimeList := f_NBIOT_RRC_CipherActTime_Get(p_CellId, localSecurityRestart);
    f_NBIOT_SS_RRC_EnableIntProt_CiphULandDL(p_CellId, v_SecurityParams.AS_Integrity, v_SecurityParams.AS_Ciphering);
  }

  /*
   * @desc      Initial security activation (36.331 cl. 5.3.4)
   * @param     p_CellId
   * @param     p_IntegrityProtAlgorithm
   * @param     p_CipheringAlgorithm
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_RRC_InitialSecurityActivation(NBIOT_CellId_Type p_CellId,
                                                 IntegrityProtAlgorithm_Type p_IntegrityProtAlgorithm,
                                                 EUTRA_ASN1_CipheringAlgorithm_r12_Type  p_CipheringAlgorithm) runs on NBIOT_PTC
  {
    var EUTRA_ASN1_RRC_TransactionIdentifier_Type v_RRC_TI := tsc_RRC_TI_Def;
    
    // send SecurityModeCommand on SRB1:
    SRB.send(cas_NB_SRB_RrcPdu_REQ(p_CellId,
                                   tsc_SRB1,
                                   cs_TimingInfo_Now,
                                   cs_508_SecurityModeCommand_NB(v_RRC_TI, p_IntegrityProtAlgorithm, p_CipheringAlgorithm)));
    // receive SecurityModeComplete on SRB1:
    SRB.receive(car_NB_SRB_RrcPdu_IND(p_CellId,
                                      tsc_SRB1,
                                      cr_508_SecurityModeComplete_NB(v_RRC_TI)));
  }

  /*
   * @desc      Activation of Initial security at SS[SRB 1 and optionally DRB 1] and at the UE
   *            (36.331 cl. 5.3.4       Initial security activation)
   *            The parameter p_UL_NAS_Count shall be the NAS count of
   *            if [AUTN procedure is executed]
   *              then: The UL NAS Count of NAS SMC Complete, of the NAS SMC procedure executed after AUTN Proc.
   *            else
   *              then: The UL NAS count of the NAS UL message[which shall be security protected] received which triggered the RRC Connection establishment
   *            i.e. Attach Req[ in special cases], TAU Req, Service Req etc.
   * @param     p_CellId
   * @param     p_SecurityParams
   * @param     p_NasCountUL
   * @param     p_DrbConfigList     (default value: omit, alternative value: cs_DrbConfigList_DRB1)
   * @return    NBIOT_SecurityParams_Type
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_RRC_ActivateSecurity(NBIOT_CellId_Type p_CellId,
                                        NBIOT_SecurityParams_Type p_SecurityParams,
                                        NasCount_Type p_NasCountUL,
                                        template (omit) NB_RadioBearerList_Type p_DrbConfigList := omit) runs on NBIOT_PTC
    return NBIOT_SecurityParams_Type
  {
    var NBIOT_SecurityParams_Type v_SecurityParams := f_NBIOT_Authentication_InitAS(p_SecurityParams,
                                                                                    p_NasCountUL); /* Calculate Kenb and KRRCenc, KRRCint, KUPenc */
    if (ispresent(p_DrbConfigList)) {
      f_NBIOT_SS_CommonRadioBearerConfig(p_CellId, valueof(p_DrbConfigList));
    }

    // Read PDCP SQN for SRB1 and calcuate Ciphering Activation times
    v_SecurityParams.AS_Ciphering.ActTimeList := f_NBIOT_RRC_CipherActTime_Get(p_CellId, initialSecurityActivation);
    // Note by default DRB is also pre-configured on SS side
    
    f_NBIOT_SS_RRC_EnableIntProt_CiphULandDL(p_CellId,
                                             v_SecurityParams.AS_Integrity,
                                             v_SecurityParams.AS_Ciphering);
    f_NBIOT_RRC_InitialSecurityActivation(p_CellId,
                                          v_SecurityParams.AS_Integrity.Algorithm,
                                          v_SecurityParams.AS_Ciphering.Algorithm);    /* SecurityModeComplete is not ciphered
                                                                                          acc. to 36.331 cl. 5.3.4.3 and 5.3.1.1 */
    return v_SecurityParams;
  }
    
    
    
    //Added VZW NBIOT for Data Retry TC 3.3
      function f_NBIOT_NAS_Authentication_SyncFailure(NBIOT_CellId_Type p_CellId,
                                      NB_SRB_Identity_Type p_SRB:= tsc_SRB1bis,
                                      NBIOT_SecurityParams_Type p_SecurityParams,
                                      SecurityHeaderType p_SecurityStatusAuthRequest,
                                      template (present) SecurityHeaderType p_SecurityStatusAuthResponse,
                                      NAS_PlmnId p_PLMN)
    runs on NBIOT_PTC
    return NBIOT_SecurityParams_Type
  {
    var NB_SRB_COMMON_IND v_ReceivedAsp;
    var B32_128_Type v_ReceivedRES;
    var NBIOT_SecurityParams_Type v_SecurityParams;
    var boolean handle_sync_failure := true;
    timer t_WaitTime;
    
    // Evaluate Authentication parameters and generate new keys
       v_SecurityParams := f_NBIOT_Authentication_InitNAS(p_SecurityParams,p_PLMN);
       v_SecurityParams.AuthParams := f_AuthenticationResync_InvalidSqn(v_SecurityParams.AuthParams); 
       v_SecurityParams := f_NBIOT_Authentication_InitNAS(v_SecurityParams,p_PLMN);
    
    
    SRB.send(cas_NB_SRB_NasPdu_REQ(p_CellId,
                                   p_SRB,
                                   cs_TimingInfo_Now,
                                   cs_NAS_Request(p_SecurityStatusAuthRequest, cs_AUTHENTICATION_REQUEST(v_SecurityParams.KSIasme,
                                                                                                         v_SecurityParams.AuthParams.RandValue,
                                                                                                         v_SecurityParams.AuthParams.AUTN))));
     log("aUTHENTICATION_REQUEST "); 
    t_WaitTime.start(f_NBIOT_SetTimerToleranceMin( nasTimer, 300.0));    
    alt 
    {           
      [] SRB.receive(car_NB_SRB_NasPdu_IND(p_CellId,
                                           p_SRB,
                                           cr_NAS_Indication(?, cr_AUTHENTICATION_SYNC_FAIL(cr_EMM_Cause_AuthFail_SQN))))
       
      {
        log(testcasename(), ": Received Authentication Failure : EMM Cause - Sync failure");
      }
      []t_WaitTime.timeout
      {
        f_NBIOT_SetVerdictFailOrInconc(__FILE__, __LINE__, "Authentication Failure : Received EMM Cause is not SYNCH failure");
      }
    }
 
    return v_SecurityParams;
  }

    
    
    //Added VZW NBIOT for Data Retry TC 3.2
     function f_NBIOT_NAS_Authentication_EMMCause26(NBIOT_CellId_Type p_CellId,
                                      NB_SRB_Identity_Type p_SRB:= tsc_SRB1bis,
                                      NBIOT_SecurityParams_Type p_SecurityParams,
                                      SecurityHeaderType p_SecurityStatusAuthRequest,
                                      template (present) SecurityHeaderType p_SecurityStatusAuthResponse,
                                      NAS_PlmnId p_PLMN)
    runs on NBIOT_PTC
    return NBIOT_SecurityParams_Type
  {
    var NB_SRB_COMMON_IND v_ReceivedAsp;
    var B32_128_Type v_ReceivedRES;
    var NBIOT_SecurityParams_Type v_SecurityParams;
    var boolean handle_sync_failure := true;
    
    // Evaluate Authentication parameters and generate new keys
       v_SecurityParams := f_NBIOT_Authentication_InitNAS(p_SecurityParams,p_PLMN);
       v_SecurityParams.AuthParams := f_AuthenticationResync(v_SecurityParams.AuthParams); 
       v_SecurityParams := f_NBIOT_Authentication_InitNAS_ZeroAMF(v_SecurityParams,p_PLMN);
    
    
    SRB.send(cas_NB_SRB_NasPdu_REQ(p_CellId,
                                   p_SRB,
                                   cs_TimingInfo_Now,
                                   cs_NAS_Request(p_SecurityStatusAuthRequest, cs_AUTHENTICATION_REQUEST(v_SecurityParams.KSIasme,
                                                                                                         v_SecurityParams.AuthParams.RandValue,
                                                                                                         v_SecurityParams.AuthParams.AUTN))));
    // receive AUTHENTICATION RESPONSE:
   log("aUTHENTICATION_REQUEST ");
    alt {
     //VZW: Added for Sync failure handling
        [px_MILENAGE_enabled and handle_sync_failure] SRB.receive(car_NB_SRB_NasPdu_IND(p_CellId,
                                        p_SRB,
                                        cr_NAS_Indication(?, cr_AUTHENTICATION_SYNC_FAIL)))
        -> value v_ReceivedAsp {
            v_SecurityParams.AuthParams.AUTS := v_ReceivedAsp.Signalling.Nas[0].Pdu.Msg.aUTHENTICATION_FAILURE.authenticationFailureParameter.auts;
            v_SecurityParams.AuthParams := f_AuthenticationResync(v_SecurityParams.AuthParams);
            log("aUTHENTICATION_FAILURE"); 
            // Evaluate Authentication parameters and generate new keys
            //p_SecurityParams.AuthParams.AUTH_SQN := v_SecurityParams.AuthParams.AUTH_SQN;
            v_SecurityParams := f_NBIOT_Authentication_InitNAS(v_SecurityParams,p_PLMN);
            SRB.send(cas_NB_SRB_NasPdu_REQ(p_CellId,
                                p_SRB,
                                cs_TimingInfo_Now,
                                cs_NAS_Request(p_SecurityStatusAuthRequest, cs_AUTHENTICATION_REQUEST(v_SecurityParams.KSIasme,
                                                                                                      v_SecurityParams.AuthParams.RandValue,
                                                                                                      v_SecurityParams.AuthParams.AUTN))));
            
               log("aUTHENTICATION_REQUEST ");
                handle_sync_failure :=false;
            repeat;
            
        }
      [] SRB.receive(car_NB_SRB_NasPdu_IND(p_CellId,
                                           p_SRB,
                                           cr_NAS_Indication(?, cr_AUTHENTICATION_FAIL_Any(cr_EMM_Cause_AuthFail_nonEPS_AuthUnacceptable))))
        {
          log(testcasename(), ": Received Authentication Failure : EMM Cause - Non-EPS Authentication Not Acceptable");
        }
    }
       log("aUTHENTICATION_RESPONSE"); 
    return v_SecurityParams;
  }

    
    
    //Added VZW NBIOT for Data Retry TC 3.1
     function f_NBIOT_NAS_Authentication_MAC_Failure(NBIOT_CellId_Type p_CellId,
                                      NB_SRB_Identity_Type p_SRB:= tsc_SRB1bis,
                                      NBIOT_SecurityParams_Type p_SecurityParams,
                                      SecurityHeaderType p_SecurityStatusAuthRequest,
                                      template (present) SecurityHeaderType p_SecurityStatusAuthResponse,
                                      NAS_PlmnId p_PLMN)
    runs on NBIOT_PTC
    return NBIOT_SecurityParams_Type
  {
    var NB_SRB_COMMON_IND v_ReceivedAsp;
    var B32_128_Type v_ReceivedRES;
    var NBIOT_SecurityParams_Type v_SecurityParams;
    var boolean handle_sync_failure := true;
    
    // Evaluate Authentication parameters and generate new keys
   
      v_SecurityParams := f_NBIOT_Authentication_InitNAS(p_SecurityParams,p_PLMN);
      v_SecurityParams := f_NBIOT_Authentication_InitNAS(v_SecurityParams, p_PLMN, f_AuthenticationInit(v_SecurityParams.AuthParams, macError));

    
    SRB.send(cas_NB_SRB_NasPdu_REQ(p_CellId,
                                   p_SRB,
                                   cs_TimingInfo_Now,
                                   cs_NAS_Request(p_SecurityStatusAuthRequest, cs_AUTHENTICATION_REQUEST(v_SecurityParams.KSIasme,
                                                                                                         v_SecurityParams.AuthParams.RandValue,
                                                                                                         v_SecurityParams.AuthParams.AUTN))));
    // receive AUTHENTICATION RESPONSE:
   log("aUTHENTICATION_REQUEST ");
    alt {
     //VZW: Added for Sync failure handling
        [px_MILENAGE_enabled and handle_sync_failure] SRB.receive(car_NB_SRB_NasPdu_IND(p_CellId,
                                        p_SRB,
                                        cr_NAS_Indication(?, cr_AUTHENTICATION_SYNC_FAIL)))
        -> value v_ReceivedAsp {
            v_SecurityParams.AuthParams.AUTS := v_ReceivedAsp.Signalling.Nas[0].Pdu.Msg.aUTHENTICATION_FAILURE.authenticationFailureParameter.auts;
            v_SecurityParams.AuthParams := f_AuthenticationResync(v_SecurityParams.AuthParams);
            log("aUTHENTICATION_FAILURE"); 
            // Evaluate Authentication parameters and generate new keys
            //p_SecurityParams.AuthParams.AUTH_SQN := v_SecurityParams.AuthParams.AUTH_SQN;
            v_SecurityParams := f_NBIOT_Authentication_InitNAS(v_SecurityParams,p_PLMN);
            SRB.send(cas_NB_SRB_NasPdu_REQ(p_CellId,
                                p_SRB,
                                cs_TimingInfo_Now,
                                cs_NAS_Request(p_SecurityStatusAuthRequest, cs_AUTHENTICATION_REQUEST(v_SecurityParams.KSIasme,
                                                                                                      v_SecurityParams.AuthParams.RandValue,
                                                                                                      v_SecurityParams.AuthParams.AUTN))));
            
               log("aUTHENTICATION_REQUEST ");
                handle_sync_failure :=false;
            repeat;
            
        }
      [] SRB.receive(car_NB_SRB_NasPdu_IND(p_CellId,
                                           p_SRB,
                                           cr_NAS_Indication(?, cr_AUTHENTICATION_FAIL_Any(cr_EMM_Cause_AuthFail_Mac))))
        {
          log(testcasename(), ": Received Authentication Failure : EMM Cause - MAC Failure");
        }
    }
       log("aUTHENTICATION_RESPONSE"); 
    return v_SecurityParams;
  }

    
    
    

  /*
   * @desc      24.301 cl. 5.4.2 Authentication procedure
   *            The parameter p_UL_NAS_Count shall be the NAS count of UL NAS message if security protected [i.e. Attach message]
   *            or the reseted NAS count.
   *            The structure for NBIOT_SecurityParams_Type passed as parameter shall have at least valid parameters for:
   *            IMSI, PLMN, NAS_IntegrityInfo_Type.NAS_IntAlgo, AS_IntegrityInfo_Type.IntProtAlgo
   *            NAS_CipheringInfo_Type.NAS_CipherAlgo, AS_CipheringInfo_Type.CiphAlgo.
   *            parameter shall be passed as TRUE if AUTHENTICATION_REQUEST & AUTHENTICATION_RESPONSE are to be NAS security protected
   *            else it shall be false.
   * @param     p_CellId
   * @param     p_SRB               (default value: tsc_SRB1bis)
   * @param     p_SecurityParams
   * @param     p_SecurityStatusAuthRequest  - Security header to be used in Auth Request
   * @param     p_SecurityStatusAuthResponse - Security heaser expected in Auth Response
   * @param     p_PLMN
   * @return    NBIOT_SecurityParams_Type
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_NAS_Authentication(NBIOT_CellId_Type p_CellId,
                                      NB_SRB_Identity_Type p_SRB:= tsc_SRB1bis,
                                      NBIOT_SecurityParams_Type p_SecurityParams,
                                      SecurityHeaderType p_SecurityStatusAuthRequest,
                                      template (present) SecurityHeaderType p_SecurityStatusAuthResponse,
                                      NAS_PlmnId p_PLMN)
    runs on NBIOT_PTC
    return NBIOT_SecurityParams_Type
  {
    var NB_SRB_COMMON_IND v_ReceivedAsp;
    var B32_128_Type v_ReceivedRES;
    var NBIOT_SecurityParams_Type v_SecurityParams;
    var boolean handle_sync_failure := true;
    
    // Evaluate Authentication parameters and generate new keys
   // log("VZW:Evaluate Authentication parameters and generate new keys");
    
    v_SecurityParams := f_NBIOT_Authentication_InitNAS(p_SecurityParams,p_PLMN);
    
    
    SRB.send(cas_NB_SRB_NasPdu_REQ(p_CellId,
                                   p_SRB,
                                   cs_TimingInfo_Now,
                                   cs_NAS_Request(p_SecurityStatusAuthRequest, cs_AUTHENTICATION_REQUEST(v_SecurityParams.KSIasme,
                                                                                                         v_SecurityParams.AuthParams.RandValue,
                                                                                                         v_SecurityParams.AuthParams.AUTN))));
    // receive AUTHENTICATION RESPONSE:
    log("AUTHENTICATION_REQUEST ");
    alt {
      [] SRB.receive(car_NB_SRB_NasPdu_IND(p_CellId,
                                           p_SRB,
                                           cr_NAS_Indication(p_SecurityStatusAuthResponse, cr_AUTHENTICATION_RESPONSE)))
        -> value v_ReceivedAsp {
        v_ReceivedRES := v_ReceivedAsp.Signalling.Nas[0].Pdu.Msg.aUTHENTICATION_RESPONSE.authenticationResponseParameter.res;
        if (v_ReceivedRES != substr(v_SecurityParams.AuthParams.XRES, 0, lengthof(v_ReceivedRES))) {
          f_NBIOT_SetVerdictFailOrInconc(__FILE__, __LINE__, "Authentication Failed");
        }
        v_SecurityParams.AuthParams.XRESLength := lengthof(v_ReceivedRES) / 8;
      }//VZW: Added for Sync failure handling
        [px_MILENAGE_enabled and handle_sync_failure] SRB.receive(car_NB_SRB_NasPdu_IND(p_CellId,
                                        p_SRB,
                                        cr_NAS_Indication(?, cr_AUTHENTICATION_SYNC_FAIL)))
        -> value v_ReceivedAsp {
            v_SecurityParams.AuthParams.AUTS := v_ReceivedAsp.Signalling.Nas[0].Pdu.Msg.aUTHENTICATION_FAILURE.authenticationFailureParameter.auts;
            v_SecurityParams.AuthParams := f_AuthenticationResync(v_SecurityParams.AuthParams);
           // log("After resync", bit2hex(v_SecurityParams.AuthParams.AUTH_SQN));
            // Evaluate Authentication parameters and generate new keys
            //p_SecurityParams.AuthParams.AUTH_SQN := v_SecurityParams.AuthParams.AUTH_SQN;
            v_SecurityParams := f_NBIOT_Authentication_InitNAS(v_SecurityParams,p_PLMN);
            log("aUTHENTICATION_FAILURE"); 
            SRB.send(cas_NB_SRB_NasPdu_REQ(p_CellId,
                                p_SRB,
                                cs_TimingInfo_Now,
                                cs_NAS_Request(p_SecurityStatusAuthRequest, cs_AUTHENTICATION_REQUEST(v_SecurityParams.KSIasme,
                                                                                                      v_SecurityParams.AuthParams.RandValue,
                                                                                                      v_SecurityParams.AuthParams.AUTN))));
            
              log("aUTHENTICATION_REQUEST"); 
                handle_sync_failure :=false;
            repeat;
            
        }
      [] SRB.receive(car_NB_SRB_NasPdu_IND(p_CellId,
                                           p_SRB,
                                           cr_NAS_Indication(?, cr_AUTHENTICATION_FAIL_Any)))
        {
          f_NBIOT_SetVerdictFailOrInconc(__FILE__, __LINE__, "Authentication Fail Message");
        }
    }
      log("aUTHENTICATION_RESPONSE"); 
    return v_SecurityParams;
  }

  /*
   * @desc      send SECURITY_MODE_COMMAND to the UE and wait for SECURITY_MODE_COMPLETE
   * @param     p_CellId
   * @param     p_SecurityParams
   * @param     p_SRB               (default value: tsc_SRB1bis)
   * @param     p_DuringRegistration (default value: false)
   * @return    NasCount_Type
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_NAS_SecurityModeControl(NBIOT_CellId_Type p_CellId,
                                           NBIOT_SecurityParams_Type p_SecurityParams,
                                           NB_SRB_Identity_Type p_SRB := tsc_SRB1bis,
                                           boolean p_DuringRegistration := false) runs on NBIOT_PTC return NasCount_Type
  {
    var NB_SRB_COMMON_IND v_ReceivedAsp;
    var NasCount_Type v_NasCountUL;
    var template (omit) UE_AdditionalSecurityCapability v_AddSecurityCap := omit;
    
    if (p_DuringRegistration and isvalue(p_SecurityParams.NAS_SecurityCap5G)) { // @sic R5-182074 sic@
      v_AddSecurityCap := p_SecurityParams.NAS_SecurityCap5G;
    }

    // send NAS SECURITY MODE COMMAND (integrity protected acc. 24.301 cl. 5.4.3.2):
    
    SRB.send(cas_NB_SRB_NasPdu_REQ(p_CellId,
                                   p_SRB,
                                   cs_TimingInfo_Now,
                                   cs_NAS_Request(tsc_SHT_IntegrityProtected_NewSecurityContext,
                                                  cs_508_SECURITY_MODE_COMMAND(p_SecurityParams.NAS_Ciphering.Algorithm,
                                                                               p_SecurityParams.NAS_Integrity.Algorithm,
                                                                               p_SecurityParams.KSIasme,
                                                                               p_SecurityParams.NAS_SecurityCap,
                                                                               v_AddSecurityCap)))); // @sic R5-182074 sic@
     log("sECURITY_MODE_COMMAND ");
    // receive NAS SECURITY MODE COMPLETE (integrity protected and ciphered acc. 24.301 cl. 5.4.3.3):
      SRB.receive(car_NB_SRB_NasPdu_IND(p_CellId,
                                      p_SRB,
                                      cr_NAS_Indication(tsc_SHT_IntegrityProtected_Ciphered_NewSecurityContext, cr_508_SECURITY_MODE_COMPLETE)))
      -> value v_ReceivedAsp;
    log("sECURITY_MODE_COMPLETE"); 
    v_NasCountUL := v_ReceivedAsp.Signalling.Nas[0].SecurityProtection.NasCount;
    return v_NasCountUL;
  }

  /*
   * @desc      Activation of NAS security at SS and at the UE (24.301 cl. 5.4.3)
   * @param     p_CellId
   * @param     p_SecurityParams
   * @param     p_SRB               (default value: tsc_SRB1bis)
   * @param     p_NasCountReset     (default value: true)
   * @param     p_DuringRegistration (default value: false)
   * @return    NasCount_Type
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_NAS_ActivateSecurity(NBIOT_CellId_Type p_CellId,
                                        NBIOT_SecurityParams_Type p_SecurityParams,
                                        NB_SRB_Identity_Type p_SRB := tsc_SRB1bis,
                                        template (omit) Null_Type p_NasCountReset := true,
                                        boolean p_DuringRegistration := false) runs on NBIOT_PTC return NasCount_Type
  {
    var NasCount_Type v_NasCountUL;
    
    f_EUTRA_NB_SS_NAS_ConfigureSecurity(NASCTRL, p_SecurityParams.NAS_Integrity, p_SecurityParams.NAS_Ciphering, p_NasCountReset); /* download security keys and reset NAS COUNT */
    
    v_NasCountUL := f_NBIOT_NAS_SecurityModeControl(p_CellId, p_SecurityParams, p_SRB, p_DuringRegistration);
    /* all NAS messages are ciphered from now on */
    return v_NasCountUL;
  }

  /*
   * @desc      To Set the AS Integrity Algorithm
   * @param     p_AS_IntegrityProtAlgorithm
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_AS_IntegrityAlgorithm_Set(IntegrityProtAlgorithm_Type p_AS_IntegrityProtAlgorithm) runs on NBIOT_PTC
  {
    var NBIOT_SecurityParams_Type v_Auth_Params := f_NBIOT_Security_Get();
    v_Auth_Params.AS_Integrity.Algorithm := p_AS_IntegrityProtAlgorithm;
    f_NBIOT_Security_Set(v_Auth_Params);
  }

  /*
   * @desc      To Set the AS Ciphering Algorithm
   * @param     p_AS_CipheringAlgorithm
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_AS_CipheringAlgorithm_Set(EUTRA_ASN1_CipheringAlgorithm_r12_Type p_AS_CipheringAlgorithm) runs on NBIOT_PTC
  {
    var NBIOT_SecurityParams_Type v_Auth_Params := f_NBIOT_Security_Get();
    v_Auth_Params.AS_Ciphering.Algorithm := p_AS_CipheringAlgorithm;
    f_NBIOT_Security_Set(v_Auth_Params);
  }

  /*
   * @desc      To Set the NAS Integrity Algorithm
   * @param     p_NAS_IntegrityProtAlgorithm
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_NAS_IntegrityAlgorithm_Set(B3_Type p_NAS_IntegrityProtAlgorithm) runs on NBIOT_PTC
  {
    var NBIOT_SecurityParams_Type v_Auth_Params := f_NBIOT_Security_Get();
    v_Auth_Params.NAS_Integrity.Algorithm := p_NAS_IntegrityProtAlgorithm;
    f_NBIOT_Security_Set(v_Auth_Params);
  }

  /*
   * @desc      To Set the NAS Ciphering Algorithm
   * @param     p_NAS_CipheringAlgorithm
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_NAS_CipheringAlgorithm_Set(B3_Type p_NAS_CipheringAlgorithm) runs on NBIOT_PTC
  {
    var NBIOT_SecurityParams_Type v_Auth_Params := f_NBIOT_Security_Get();
    v_Auth_Params.NAS_Ciphering.Algorithm := p_NAS_CipheringAlgorithm;
    f_NBIOT_Security_Set(v_Auth_Params);
  }

  /*
   * @desc      Common function to release NAS security
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_SS_NAS_SecurityRelease() runs on NBIOT_PTC
  {
    f_EUTRA_NB_SS_NAS_SecurityConfig(NASCTRL, cas_NasSecurityRelease_REQ);
  }

  /*
   * @desc      depending on the given format p_PdcpCount is converted to integer
   * @param     p_PdcpCount
   * @return    NB_PdcpSQN_Type
   * @status    APPROVED (NBIOT)
   */
  function fl_NBIOT_SQN_ConvertFromPdcpCount(NB_PdcpCount_Type p_PdcpCount) return NB_PdcpSQN_Type
  {
    var NB_PdcpSQN_Type v_PdcpSQN;
    var bitstring v_Bitstring := p_PdcpCount.Value;
    
    select (p_PdcpCount.Format) {
      case (PdcpCount_Srb) {
        v_Bitstring := substr(v_Bitstring, 27, 5);
      }
      case (PdcpCount_DrbShortSQN) {
        v_Bitstring := substr(v_Bitstring, 25, 7);
      }
    }
    v_PdcpSQN.Format := p_PdcpCount.Format;
    v_PdcpSQN.Value := bit2int(v_Bitstring);
    return v_PdcpSQN;
  }

  /*
   * @desc      increment PDCP SQN
   * @param     p_PdcpSQN
   * @return    NB_PdcpSQN_Type
   * @status    APPROVED (NBIOT)
   */
  function fl_NBIOT_SQN_Increment(NB_PdcpSQN_Type p_PdcpSQN) return NB_PdcpSQN_Type
  {
    var NB_PdcpSQN_Type v_PdcpSQN := p_PdcpSQN;
    
    select (p_PdcpSQN.Format) {
      case (PdcpCount_Srb) {
        v_PdcpSQN.Value := (p_PdcpSQN.Value + 1) mod 32;
      }
    }
    return v_PdcpSQN;
  }

  /*
   * @desc      Common functon to enquire PDCP sequence numbers
   * @param     p_CellId
   * @return    NB_PdcpCountInfoList_Type
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_SS_PdcpCount_GetAll(NBIOT_CellId_Type p_CellId) runs on NBIOT_PTC return NB_PdcpCountInfoList_Type
  {
    var NB_SYSTEM_CTRL_CNF  v_ReceivedAsp;
    
    SYS.send   (cas_NB_PdcpCount_REQ (p_CellId, cs_NB_PDCP_CountGet_AllRBs));
    SYS.receive(car_NB_PdcpCount_CNF(p_CellId, {Get := ?})) -> value v_ReceivedAsp;

    return v_ReceivedAsp.Confirm.PdcpCount.Get;
  }

  /*
   * @desc      set pdcp count at the given cell
   * @param     p_CellId
   * @param     p_PdcpCountInfoList
   * @param     p_TimingInfo         (default value: cs_TimingInfo_Now)
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_SS_PdcpCount_Set(NBIOT_CellId_Type p_CellId,
                                    template (value) NB_PdcpCountInfoList_Type p_PdcpCountInfoList,
                                    template (value) TimingInfo_Type p_TimingInfo := cs_TimingInfo_Now) runs on NBIOT_PTC
  {
    var boolean v_CnfFlag := f_TimingInfo_IsNow(p_TimingInfo);
    var template (present) NB_PDCP_CountCnf_Type v_PDCP_CountCnf := {Set := true};

    SYS.send(cas_NB_PdcpCount_REQ(p_CellId, cs_NB_PDCP_CountSet(p_PdcpCountInfoList), p_TimingInfo));
    if (v_CnfFlag) {
      SYS.receive(car_NB_PdcpCount_CNF(p_CellId, v_PDCP_CountCnf));
    }
  }

  /*
   * @desc      return list of DRBs which are currently configured at the SS
   * @param     p_CellId
   * @param     p_IOT_State
   * @return    DRB_IdentityList_Type
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_SS_ActiveDRBs(NBIOT_CellId_Type p_CellId,
                                 IOT_STATE_Type p_IOT_State) runs on NBIOT_PTC return DRB_IdentityList_Type
  {
    var NB_PdcpCountInfoList_Type v_PdcpCountInfoList;
    var DRB_IdentityList_Type v_DrbIdList := {};
    var integer k := 0;
    var integer i;

    if (p_IOT_State == USER_PLANE) {                                        /* @sic R5s180596 sic@ */
      v_PdcpCountInfoList := f_NBIOT_SS_PdcpCount_GetAll(p_CellId);
      for (i := 0; i < lengthof(v_PdcpCountInfoList); i := i + 1) {
        if (ischosen(v_PdcpCountInfoList[i].RadioBearerId.Drb)) {
          v_DrbIdList[k] := v_PdcpCountInfoList[i].RadioBearerId.Drb;
          k := k + 1;
        }
      }
    }
    return v_DrbIdList;
  }

  type enumerated NBIOT_CipherActTimePrcedure_Type {  /* @status    APPROVED (NBIOT) */
    initialSecurityActivation,           // 36.331 clause 5.3.4: SecurityModeCommand/SecurityModeComplete
    rrcConnectionReestablishment,        // 36.331 clause 5.3.7.5
    rrcConnectionResume,                 // 36.331 clause 5.3.3.4a
    localSecurityRestart                 // e.g. when another DRB is added after RRC connection has been established already
  };

  /*
   * @desc      true, if bearer is SRB1
   * @param     p_RadioBearerId
   * @return    boolean
   * @status    APPROVED (NBIOT)
   */
  function fl_NBIOT_RadioBearerId_IsSRB1(NB_RadioBearerId_Type p_RadioBearerId) return boolean
  {
    return ischosen(p_RadioBearerId.Srb) and (p_RadioBearerId.Srb == tsc_SRB1);
  }

  /*
   * @desc      Common functon to enquire PDCP sequence numbers and generate a ciphering activation list for SRB1 and DRBs
   * @param     p_CellId
   * @param     p_Procedure
   * @return    NB_SecurityActTimeList_Type
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_RRC_CipherActTime_Get(NBIOT_CellId_Type p_CellId,
                                         NBIOT_CipherActTimePrcedure_Type p_Procedure)
    runs on NBIOT_PTC return NB_SecurityActTimeList_Type
  {
    var NB_PdcpCountInfoList_Type v_PdcpCountInfoList := f_NBIOT_SS_PdcpCount_GetAll(p_CellId);
    var NB_PdcpCountInfo_Type v_PdcpCountInfo;
    var NB_PDCP_ActTime_Type v_PDCP_ActTimeUL;
    var NB_PDCP_ActTime_Type v_PDCP_ActTimeDL;
    var NB_SecurityActTime_Type v_SecurityActTime;
    var NB_RadioBearerId_Type v_RadioBearerId;
    var NB_SecurityActTimeList_Type v_SecurityActTimeList;
    var integer i;

    for (i := 0; i < lengthof(v_PdcpCountInfoList); i:= i + 1) {
      v_PdcpCountInfo := v_PdcpCountInfoList[i];
      v_RadioBearerId := v_PdcpCountInfo.RadioBearerId;

      if ((not ispresent(v_PdcpCountInfo.UL)) or (not ispresent(v_PdcpCountInfo.DL))) {
        FatalError(__FILE__, __LINE__, "missing PdcpCountInfo for UL or DL");
      }

      // Convert PdcpCount to integer value (UL an DL)
      v_PDCP_ActTimeUL.SQN := fl_NBIOT_SQN_ConvertFromPdcpCount(v_PdcpCountInfo.UL);
      v_PDCP_ActTimeDL.SQN := fl_NBIOT_SQN_ConvertFromPdcpCount(v_PdcpCountInfo.DL);
      
      if (fl_NBIOT_RadioBearerId_IsSRB1(v_RadioBearerId)) {
        select (p_Procedure) {
          case (initialSecurityActivation) {
            v_PDCP_ActTimeDL.SQN := fl_NBIOT_SQN_Increment(v_PDCP_ActTimeDL.SQN);  // SecurityModeCommand is not ciphered and ...
            v_PDCP_ActTimeUL.SQN := fl_NBIOT_SQN_Increment(v_PDCP_ActTimeUL.SQN);  // ... acc. to 36.331 5.3.4.3 SecurityModeComplete is not ciphered either
          }
          case (rrcConnectionReestablishment) {
            // reset count values of SRB1
            v_PDCP_ActTimeUL.SQN.Value := 0;
            v_PDCP_ActTimeDL.SQN.Value := 0;
          }
          case (rrcConnectionResume) {
            v_PDCP_ActTimeDL.SQN := fl_NBIOT_SQN_Increment(v_PDCP_ActTimeDL.SQN);  // RRCConnectionResume is not ciphered but RRCConnectionResumeComplete is ciphered (36.331 5.3.3.4a)
          }
          case (localSecurityRestart) {
            // nothing to be done for SRB1
          }
        }
      }

      v_SecurityActTime.RadioBearerId := v_PdcpCountInfo.RadioBearerId;
      v_SecurityActTime.UL := v_PDCP_ActTimeUL;
      v_SecurityActTime.DL := v_PDCP_ActTimeDL;

      v_SecurityActTimeList[i] := v_SecurityActTime;
    }
    return v_SecurityActTimeList;
  }

  /*
   * @desc      Get PDCP count for SRB1
   * @param     p_CellId
   * @return    NB_PdcpCountInfo_Type
   * @status    APPROVED (NBIOT)
   */
  function fl_NBIOT_SS_PdcpCount_GetSRB1(NBIOT_CellId_Type p_CellId)
    runs on NBIOT_PTC return NB_PdcpCountInfo_Type
  {
    var NB_PdcpCountInfoList_Type v_PdcpCountInfoListAll := f_NBIOT_SS_PdcpCount_GetAll(p_CellId);
    var NB_PdcpCountInfo_Type v_PdcpCountInfo;
    var integer i;
    
    for (i := 0; i < lengthof(v_PdcpCountInfoListAll); i:= i + 1) {
      v_PdcpCountInfo := v_PdcpCountInfoListAll[i];
        if (match(v_PdcpCountInfo, cr_NB_PdcpCountInfo_SRB(tsc_SRB1))) {
        return v_PdcpCountInfo;
      }
    }
    FatalError(__FILE__, __LINE__, "no PDCP count for SRB1");
    return v_PdcpCountInfo;
  }

  /*
   * @desc      Common functon to enquire PDCP sequence numbers and generate a Integrity activation list for SRB1
   * @param     p_CellId
   * @return    NB_SecurityActTimeList_Type
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_RRC_IntActTime_GetSRB(NBIOT_CellId_Type p_CellId)
    runs on NBIOT_PTC return NB_SecurityActTimeList_Type
  {
    var NB_SecurityActTimeList_Type v_SecurityActTimeList;
    var NB_PdcpCountInfo_Type v_PdcpCountInfo := fl_NBIOT_SS_PdcpCount_GetSRB1(p_CellId);
    
    v_SecurityActTimeList[0].RadioBearerId := v_PdcpCountInfo.RadioBearerId;
    v_SecurityActTimeList[0].UL.SQN := fl_NBIOT_SQN_ConvertFromPdcpCount(v_PdcpCountInfo.UL);
    v_SecurityActTimeList[0].DL.SQN := fl_NBIOT_SQN_ConvertFromPdcpCount(v_PdcpCountInfo.DL);
    
    return v_SecurityActTimeList;
  }

  /*
   * @desc      configure SS with different integrity algorithm to get MAC-I failure at UE on SRB1
   * @param     p_TargetCellId
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_SS_TriggerMAC_I_Failure(NBIOT_CellId_Type p_TargetCellId) runs on NBIOT_PTC
  {
    var NBIOT_SecurityParams_Type v_SecurityParams := f_NBIOT_Security_Get();
    
    // Toggle the Integrity Algorithm
    if (v_SecurityParams.AS_Integrity.Algorithm == eia1) {
      v_SecurityParams.AS_Integrity.Algorithm := eia2;
    } else {
      v_SecurityParams.AS_Integrity.Algorithm := eia1;
    }
    // Read PDCP SQN for SRB1 and calcuate Integrity Activation times
    v_SecurityParams.AS_Integrity.ActTimeList := f_NBIOT_RRC_IntActTime_GetSRB(p_TargetCellId);
    // Note by default DRB is also pre-configured on SS side
    
    f_NBIOT_SS_RRC_EnableIntegrityProtection(p_TargetCellId, v_SecurityParams.AS_Integrity);
  }

  /*
   * @desc      Function to calculate shortMAC-I that is used as a parameter in RRCConnectionReestablishmentRequest
   * @param     p_CellId_Source
   * @param     p_CellId_Current    (default value: omit)
   * @param     p_ResumeDiscriminator (default value: omit)
   * @return    EUTRA_ASN1_ShortMAC_I_Type
   * @status    APPROVED (NBIOT)
   */
  function f_NBIOT_Calculate_ShortMAC(NBIOT_CellId_Type p_CellId_Source,
                                      template (omit) NBIOT_CellId_Type p_CellId_Current := omit,
                                      template (omit) B1_Type p_ResumeDiscriminator := omit) runs on NBIOT_PTC return EUTRA_ASN1_ShortMAC_I_Type
  { /* @sic R5s170515 change 7: p_ResumeDiscriminator sic@ */
    var NBIOT_CellId_Type v_CellId_Current := p_CellId_Source;
    var EUTRA_ASN1_ShortMAC_I_Type v_ShortMAC_I;
    var O4_Type v_CalculatedMac;
    var NBIOT_SecurityParams_Type v_SecurityParams := f_NBIOT_Security_Get();
    var VarShortMAC_Input_Type v_VarShortMAC_Input;
    var octetstring v_Encoded_VarShortMAC_Input;
    var O4_Type v_PdcpCount := 'FFFFFFFF'O;
    var B5_Type v_BearerId := '11111'B;
    var integer v_Direction := 1;
    
    if (ispresent(p_CellId_Current)) {
      v_CellId_Current := valueof(p_CellId_Current);
    }

    v_VarShortMAC_Input.cellIdentity := f_NBIOT_CellInfo_GetCellIdentity(v_CellId_Current);/* Acc. 36.331 ch. 7.1 Set to CellIdentity of the current cell. */
    v_VarShortMAC_Input.physCellId := f_NBIOT_CellInfo_GetPhyCellId(p_CellId_Source);      /* Set to the physical cell identity of the cell the UE was connected to prior to the failure. */
    v_VarShortMAC_Input.c_RNTI := f_NBIOT_CellInfo_GetC_RNTI(p_CellId_Source);             /* Set to C-RNTI that the UE had in the cell it was connected to prior to the failure. */
    
    log("v_VarShortMAC_Input:",v_VarShortMAC_Input);
    /* According to 36.331 cl. 5.3.7.4
       2>  set the shortMAC-I to the 16 least significant bits of the MAC-I calculated:
       3>  over the ASN.1 encoded VarShortMAC-Input;
       3>  with the KRRCint key and integrity protection algorithm that was used in the
       source cell (handover and mobility from E-UTRA failure) or of the cell in which
       the trigger for the re-establishment occurred (other cases); and
       3>  with all input bits for COUNT, BEARER and DIRECTION set to binary ones; */
    
    v_Encoded_VarShortMAC_Input := f_EUTRA_NB_VarShortMAC(v_VarShortMAC_Input, p_ResumeDiscriminator);
    log("v_Encoded_VarShortMAC_Input:", v_Encoded_VarShortMAC_Input);
     log("v_SecurityParams:", v_SecurityParams); 
    v_CalculatedMac := fx_AsIntegrityAlgorithm(v_Encoded_VarShortMAC_Input,
                                               v_SecurityParams.AS_Integrity.Algorithm,
                                               v_SecurityParams.AS_Integrity.KRRCint,
                                               v_PdcpCount,
                                               v_BearerId,
                                               v_Direction);
    
    v_ShortMAC_I := substr(oct2bit(v_CalculatedMac),16,16); /* According to 36.331 ch. 5.3.7.4 2 Set the shortMAC-I to the 16 least significant bits of the MAC-I calculated */
    
    return v_ShortMAC_I;
  }

}
